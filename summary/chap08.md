#Chapter 08 데이터 체계화
- 필드 자체 캡슐화 Self Encapsulate Field
- 데이터 값을 객체로 전환 Replace Data Value with Object
- 값을 참조로 전환 Change Value to Reference
- 참조를 값으로 전환 Change Reference to Value
- 배열을 객체로 전환 Replace Array with Object 
- 관측 데이터 복제 Duplicate Observed Data
- 클래스의 단방향 연결을 양방향으로 전환 Change Unidirectional Association to Bidirectional
- 클래스의 양방향 연결을 단방향으로 전환 Change Bidirectional Association to Unidirectional
- 마법 숫자를 기호 상수로 전환 Replace Magic Number with Symbolic Constant
- 필드 캡슐화 Encapsulate Field
- 컬렉션 캡슐화 Encapsulate Collection
- 레코드를 데이터 클래스로 전환 Replace Record with Data Class
- 분류 부호를 클래스로 전환 Replace Type Code with Class
- 분류 부호를 하위클래스로 전환 Replace Type Code with Subclasses
- 분류 부호를 상태/전략 패턴으로 전환 Replace Type Code with State/Strategy
- 하위 클래스를 필드로 전환 Replace Subclass with Fields

---

## 필드 자체 캡슐화 Self Encapsulate Field
- 필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐 그 필드용 읽기/쓰기 메서드를 작성해서 두 메서드를 통해서만 필드에 접근하게 만들자

**[BEFORE]**
```java
private int low, high;
boolean includes (int arg) {
    return arg >= log && arg <= high;
}
```

**[AFTER]**
```java
private int low, high;
boolean includes (int arg) {
    return arg >= getLow() && arg <= getHigh();
}
int getLow() {return log;}
int getHigh() {return high;}
```

### 동기
- 변수 직접 접근파 vs 변수 간접 접근파
- 변수 간접 접근 방식
  - 하위클래스가 메서드에 해당 정보를 가져오는 방식을 재정의할 수 있다
  - 데이터 관리가 유연해진다.
- 변수 직접 접근 방식
  - 코드를 알아보기 쉽다.

### 방법
- 필드 읽기 메서드와 쓰기 메서드를 작성
- 그 필드 참조 부분을 전부 찾아서 읽기 메서드와 쓰기 메서드로 고치자  
- 필드를 private으로 만들자
- 테스트 

---
## 데이터 값을 객체로 전환 Replace Data Value with Object
- 데이터 항목에 데이터나 기능을 더 추가해야 할 때는 데이터 항목을 객체로 만들자

###동기  
- 주로 개발 초기 단계에서는 단순 정보를 간단한 데이터 항목으로 표현  
- 항목이 복잡해지면 '중복 코드'나 '잘못된 소속' 등 구린내 발생

### 방법  
- 데이터 값을 넣을 클래스를 작성 k
  - 그 클래스에 원본 클래스 안의 값과 같은 타입의 final 필드를 추가
  - 해당 필드를 인자로 받는 생성자와 읽기 메서드 추가  
- 원본 클래스에 든 필드릐 타입을 새 클래스로 바꾸자  
- 원본 클래스 안의 읽기 메서드를 새 클래스의 읽기 메서드를 호출하게 수정 
- 그 필드가 원본 클래스 생성자 안에 사용되면 새 클래스의 생성자를 이용해서 필드에 대입  
- 새 클래스의 새 인스턴스를 생성하게끔 읽기 메서드를 수정  
- 컴파일, 테스트 

---
## 값을 참조로 전환 Change Value to Reference
- 클래스에 같은 인스턴스가 많이 들어있어서 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환하자

### 동기 
- 많은 시스템에서 객체를 참조 객체와 값 객체로 분류할 수 있다. 
  - 참조 객체 : 고객이나 계좌 같은 것
    - 각 객체는 현실에서의 한 객체에 대응하므로 둘이 같은지 검사할때 객체 ID사용  
  - 값 객체 : 날짜나 돈 같은 것, 전적으로 데이터 값을 통해서만 정의된다. 
    - equals 메서드나 hashCode 메서드를 재정의 해서 같은지 판단 

### 방법
- 생성자를 팩토리 메서드로 전환 
- 컴파일, 테스트 
- 참조 객체로의 접근을 담당할 객체를 정하자
  - 이 기능은 정적 딕셔너리나 레지스트리 객체가 담당할 수도 있다.
  - 참조 객체로의 접근을 둘 이상의 객체가 담당할 수도 있다.  
- 객체를 미리 생성할지 사용하기 직전에 생성할지 정하자
  - 객체를 미리 생성했다가 메모리에서 가져오면 사용 전에 미리 로딩되어 있는지 확인해야 한다.?
- 참조 객체를 반환하게 팩토리 메서드를 수정하자  
  - 객체를 미리 생성할 경우, 존재하지 않는 객체 요청에 대한 에러 처리를 어떻게 할지 정해야 한다. 
  - 팩토리 메서드가 원본 객체를 반환함을 한눈에 알 수 있게 팩토리 메서드에 메서드명 변경을 적용해야 할 수도 있다.
- 컴파일, 테스트  

---
## 참조를 값으로 전환 Change Reference to Value
- 참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조 객체를 값 객체로 만들자 

### 동기 
- 참조 객체와 값 객체 중 무엇을 사용할지 판단하기가 쉽지 않다. 
- 참조 객체를 사용한 작업이 복잡해지는 순간이 참조를 값으로 바꿔야 할 시점 
  - 참조 객체는 어떤 식으로든 제어되어야 한다.? 
- 값 객체는 변경할 수 없어야 한다는 주요 특성이 있다. ?
  - 하나에 대한 질의를 호출하면 항상 결과가 같아야 한다. 그렇기만 하면 같은 것을 나타내는 객체가 많아도 문제가 없다.  
- '변경 불가'의 뜻을 명확히 해야 한다.
  - currency와 value가 들어있는 Money 클래스가 있다면 그 클래스는 대체로 변경불가인 값 객체다.  
  - 월급을 변경하려면 기존 Money 객체에 들어있는 양을 수정할 게 아니라 기존의 Money 객체를 새 Money 객체로 교체해야 한다. 
  - 관계를 바꿀 수 있지만 Money 객체 자체를 바꿀 수 없다. 

### 방법 
- 전환할 객체가 변경불가인지 변경 가능인지 검사하자?  
  - 전환할 객체가 변경불가가 아니면, 변경불가가 될때까지 쓰기 메서드 제거를 실시하자.
  - 전환할 객체가 변경불가이면 이 리팩토링은 관두자 
- equals 메서드와 hash 메서드를 작성하자 
- 컴파일, 테스트  
- 팩토리 메서드를 삭제하고 생성자를 public으로 만들어야 좋을지 생각해보자.  

## 배열을 객체로 전환 Replace Array with Object  
- 배열을 구성하는 특정 원소가 별의별 의미를 지닐 땐 그 배열을 각 원소마다 필드가 하나씩 든 객체로 전환하자  

**[BEFORE]**
```java
String[] row = new String[3];
row[0] = "Liverpool";
row[1] = "15;"
```
**[AFTER]**
```java
Performance row = new Performance();
row.setName("Liverpool");
row.setWins("15");
```

### 동기 
- 배열은 데이터 정리에 흔히 사용되는 구조다. 
  - 그러나 비슷한 객체들의 컬렉션을 일정 순서로 담는 용도로만 사용해야 한다.
- 객체를 사용하면 필드명과 메서드명을 사용하여 이러한 정보를 전달할 수 있다. 

### 방법 
- 배열 안의 정보를 표현할 새 클래스를 작성하자. 그 클래스 안에 배열을 저장할 public 필드를 하나 작성하자.  
- 배열 참조 부분을 전부 새 클래스 참조로 수정하자.
- 컴파일, 테스트 
- 배열의 각 원소마다 참조 코드에 사용할 읽기 메서드를 하나씩 넣자. 
  - 배열 원소의 용도를 따서 읽기 메서드 이름을 정하자. 
  - 참조 부분을 읽기 메서드 호출로 전부 수정하자. 
- 배열 참조 부분을 전부 메서드로 교체했으면 배열을 private로 만들자 
- 컴파일
- 클래스 안에 배열의 각 원소에 대응되는 하나의 필드를 생성한 후, 그 필드를 사용하게끔 읽기/쓰기 메서드를 수정하자 
- 각 원소에 대한 수정을 마칠 때마다 컴파일, 테스트 
- 모든 원소를 필드로 교체했으면 배열을 삭제

---
## 관측 데이터 복제 Duplicate Observed Data  
- 도메인 데이터는 GUI 컨트롤 안에서만 사용 가능한데, 도메인 메서드가 그 데이터에 접근해야 할 땐 
_그 데이터를 도메인 객체로 복사하고, 양측의 데이터를 동기화하는 관측 인터페이스 observer를 작성하자_

### 동기  
- 계층구조가 체계적인 시스템은 비즈니스 로직 처리 코드와 사용자 인터페이스 처리 코드가 분리되어 있다. 
  - 비슷한 비즈니스 로직을 여러 인터페이스가 처리해야 하는 경우라서 
  - 비즈니스 로직까지 처리하려면 사용자 인터페이스가 너무 복잡해지니까
  - GUI와 분리된 도메인 객체가 더욱 유지보수하기 쉬우니까 
  - 두 부분을 서로 다른 개발자가 다루게 할 수 있으니까 

### 방법
- 표현 클래스를 도메인 클래스의 관측 인터페이스로 만들자  
  - 도메인 클래스가 없으면 하나 작성하자 
  - 표현 클래스에 도메인 클래스로의 연결 코드가 없으면 표현 클래스의 필드에 도메인 클래스를 대입하자 
- GUI 클래스 안의 도메인 데이터를 대상으로 필드 자체 캡슐화를 실시하자 
- 컴파일, 테스트  
- 이벤트 핸들러 메서드 안에 쓰기 메서드 호출 코드를 추가하자. 이 쓰기 메서드는 직접 접근 방식으로 컴포넌트를 현재 값으로 수정한다.  
- 컴파일, 테스트 
- 도메인 클래스 안에 데이터와 읽기/쓰기 메서드를 정의하자 
- 쓰기 메서드가 도메인 필드에 쓰도록 참조를 수정하자 
- 관측 인터페이스의 update 메서드를 도메인 필드에서 GUI 컨트롤로 데이터를 복사하게 수정하자  
- 컴파일, 테스트 

---
## 클래스의 단방향 연결을 양방향으로 전환 Change Unidirectional Association to Bidirectional
- 두 클래스가 서로의 기능을 사용해야 하는데 한 방향으로만 연결되어 있을 땐 역 포인터를 추가하고 두 클래스를 모두 업데이트할 수 있게 접근 한정자를 수정하자  

___
## 마법 숫자를 기호 상수로 전환 Replace Magic Number with Symbolic Constant
- 특수 의미를 지닌 리터럴 숫자가 있을 땐 의미를 살린 이름의 상수를 작성한 후 리터럴 숫자를 그 상수로 교체하자 

**[BEFORE]**
```java
double potentialEnergy(double mass, double height) {
    return mass * 9.81 * height;
}
```
**[AFTER]**
```java
double potentialEnergy(double mass, double height) {
    return mass * GRAVITATIONAL_CONSTANT * height;
}
static final double GRAVITATIONAL_CONSTANT = 9.81;
```

---
## 필드 캡슐화 Encapsulate Field
- public 필드가 있을 땐 그 필드를 private로 만들고 필드용 읽기 메서드오 쓰기 메서드를 작성하자 

**[BEFORE]**
```java
public String name;
```
**[AFTER]**
```java
private String name;
public String getName() {return name;}
public void setName(String arg) {name = arg;}
```

## 동기  
- 객체지향의 주요 원칙 중 하나는 캡슐화(데이터 은닉)
  - 데이터는 절대로 public 타입으로 선언하면 안된다. 
  - 데이터를 public 타입으로 만들면 데이터가 있는 객체가 모르는 사이에 다른 객체가 값을 읽고 변경할 수 있다. 
- 프로그램의 모듈성을 저하시키는 것이 문제
  - 데이터와 데이터를 사용하는 기능이 한 곳에 있어야 코드를 수정하기 쉽다.
- 필드 캡슐화 과정의 첫 단계는 데이터를 은닉하고 읽기/쓰기 메서드를 추가하는 것  
  - 읽기 메서드와 쓰기 메서드만 있는 클래스는 객체의 장점을 전혀 활용하지 않아서 객체라는 이름이 아까운 dumb class 
  - 필드 캡슐화를 적용한 후엔 새 메서드를 사용하는 메서드를 찾아 그 메서드를 묶어서 가단한 메서드 이동을 적용해 새 객체로 옮겨도 괜찮을지 확인

---
## 컬렉션 캡슐화 Encapsulate Collection
- 메서드가 컬렉션을 반환할 땐 그 메서드가 _읽기전용 뷰를 반환_ 하게 수정하고 추가 메서드와 삭제 메서드를 작성하자

### 동기
- 클래스에 여러 인스턴스로 구성된 컬렉션이 들어있는 경우는 흔하다.
- 컬렉션은 다른 종류의 데이터와 다른 읽기/쓰기 방식을 사용해야 한다.
  - 컬렉션 조작이 불가능한 형식을 반환하고 불필요하게 자세한 컬렉션 구조 정보는 감춰야 한다.
  - 컬렉션 쓰기 메서드는 절대 있으면 안되므로 원소를 추가하는 메서드와 삭제하는 메서드를 대신 사용해야 한다.
  - 이러한 규칙대로 설계를 고치면 컬렉션은 적절히 캡슐화되어 컬렉션이 든 클래스의 컬렉션 참조 부분에 대한 종속성이 줄어든다.  

### 방법
- 컬렉션 원소를 추가하는 add 메서드와 삭제하는 remove 메서드를 추가하자
- 필드를 빈 컬렉션으로 초기화 
- 컴파일
- 쓰기 메서드 호출 부분을 찾아 add, remove 메서드 호출로 바꾸거나 그 위치에 직접 컬렉션에 원소를 추가하고 삭제하는 코드를 작성하자  
  - 쓰기 메서드가 사용되는 경우는 1) 컬렉션이 비어 있을 때, 2) 비어있지 않은 컬렉션을 교체할 때
  - 메서드명 변경을 실시해서 쓰기 메서드의 이름을 변경해야 할 수도 있다.
- set 이라는 이름을 initialize나 replace로 수정하자.
- 컴파일, 테스트 
- 읽기 메서드를 호출하여 컬렉션을 변경하는 부분을 add, remove 호출로 바꾸자.
- 컬렉션을 변경하고자 읽기 메서드를 호출하는 부분을 추가/삭제 메서드 호출로 고쳤으면 컬렉션의 읽기 전용 뷰를 반환하게 읽기 메서드를 수정
- 컴파일, 테스트 
- 읽기 메서드 호출 부분을 찾고 컬렉션이 든 객체로 옮겨야 할 코드를 찾아서 메서드 추출, 메서드 이동을 실시해서 컬렉션이 든 객체로 옮기자











