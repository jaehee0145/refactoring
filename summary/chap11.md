#Chapter 11 일반화 처리
- 필드 상향 Pull Up Field
- 메서드 상향 Pull Up Method
- 생성자 내용 상향 Pull Up Constructor Body
- 메서드 하향 Push Down Method
- 필드 하향 Push Down Field
- 하위클래스 추출 Extract Subclass
- 상위클래스 추출 Extract Superclass
- 인터페이스 추출 Extract Interface
- 계층 병합 Collapse Hierarchy
- 템플릿 메서드 형성 Form Template Method
- 상속을 위임으로 전환 Replace Inheritance with Delegation
- 위임을 상속으로 전환 Replace Delegation with Inheritance

---
## 필드 상향 Pull Up Field
- 두 하위 클래스에 같은 필드가 들어 있을 땐 필드를 상위클래스로 옮기자

### 동기
- 중복된 필드가 서로 비슷한 방식으로 사용된다면 그 필드를 일반화
  - 일반화: 상위클래스로 옮기는 작업
- 두 가지 측면에서 중복 제거
  1) 데이터 선언의 중복
  2) 해당 필드를 사용하는 기능의 중복

### 방법
- 상위 클래스로 옮길 필드가 사용된 모든 부분을 검사해서 같은 방식으로 사용하는지 확인
- 필드의 이름이 같지 않다면 변경
- 컴파일, 테스트
- 상위클래스 안에 새 필드 작성
- 하위 클래스 필드 삭제
- 컴파일, 테스트 
- 새 필드에 필드 자체 캡슐화 적용 고려 
  - 필드 자체 캡슐화: getter, setter만을 통해서 해당 필드에 접근하게 만드는 방법

---
## 메서드 상향 Pull Up Method
- 기능이 같은 메서드가 여러 하위클래스에 들어 있을 땐 그 메서드를 상위클래스로 옮기자

### 동기
- 중복된 기능을 없애는 일은 중요하다. 기능이 중복된 두 메서드가 문제없이 돌아가더라도... 향후 발생할 버그의 온상

### 방법
- 메서드가 서로 같은지 검사
  - 거의 비슷하면 알고리즘 전환을 적용해 메서드를 똑같이 만들자
- 메서드의 시그니처가 서로 다르면 모든 시그니처를 상위 클래스에 사용하고자 하는 시그니처로 수정
- 상위클래스 안에 새 메서드를 작성하고 새 메서드 안에 같은 메서드의 내용을 복사 
- 하위클래스 메서드 삭제

---
## 생성자 내용 상향 Pull Up Constructor Body
- 하위클래스마다 거의 비슷한 내용의 생성자가 있을 땐 상위클래스에 생성자를 작성하고, 그 생성자를 하위 클래스의 메서드에서 호출하자
[BEFORE]
```java
Class Manager extends Employee...
    public Manager (String name, String id, int grade) {
        this.name = name;
        this.id = id;
        this.grade = grade;
    }
```
[AFTER]
```java
public Manager (String name, String id, int grade) {
    super(name, id);
    this.grade = grade;
}
```
### 동기
- 생성자는 상속이 불가능하기 때문에 메서드 상향을 적용할 수 없다.
- 상위클래스의 생성자 메서드를 하위클래스가 호출하게 해야 한다.

### 방법
- 상위클래스에 생성자를 정의
- 하위클래스 생성자에서 앞 부분의 공통적인 코드를 상위클래스 생성자 안으로 옮기자
- 하위클래스 생성자 안의 맨 앞에 상위클래스 생성자 호출 코드를 넣자 
- 컴파일, 테스트 

---
## 메서드 하향 Push Down Method
- 상위클래스에 있는 기능을 일부 하위클래스만 사용할 땐 그 기능을 관련된 하위클래스 안으로 옮기자

### 동기
- 상위클래스의 기능을 특정 하위클래스로 옮길 때 사용
- 하위클래스 추출 기법을 실시할 때 흔히 사용

### 방법
- 모든 하위클래스에 메서드를 하나 선언하고 그 메서드의 내용을 각 하위클래스로 복사
- 상위클래스의 메서드 삭제
- 컴파일, 테스트
- 해당 메서드가 필요없는 하위클래스에서 삭제
- 컴파일, 테스트

--- 
## 필드 하향 Push Down Field
- 일부 하위클래스만이 사용하는 필드가 있을 땐 그 필드를 사용하는 하위클래스로 옮기자  

---
## 하위클래스 추출 Extract Subclass
- 일부 인스턴스에만 사용되는 기능이 든 클래스가 있을 땐 그 기능 부분을 전담하는 하위클래스를 작성하자  

### 동기
- 하위클래스 추출(상속) 대신 클래스 추출(위임) 기법을 사용할 수 있다.
- 하위클래스 추출이 보통 더 간단하지만 단점이 있다.
  1) 객체가 생성된 후에는 객체의 클래스 기반 기능을 수정할 수 없다.
  2) 하위클래스를 사용해서 한가지 변형만을 표현할 수도 있다.?

### 방법
- 원본클래스에 새 하위클래스를 정의
- 하위클래스에 생성자 메서드를 작성
- 상위클래스의 생성자를 호출하는 부분을 전부 찾고 그 부분이 하위클래스를 사용하면 새로 작성한 생성자 호출로 수정
- 메서드 하향, 필드 하향을 차례로 적용
- 계층구조가 나타내는 정보가 저장되는 필드가 있는지 찾아 제거

---
## 상위클래스 추출 Extract Superclass
- 기능이 비슷한 두 클래스가 있을 땐 상위클래스를 작성하고 공통된 기능들을 그 상위클래스로 옮기자  

### 동기
- 빈 abstract 타입의 상위클래슬 작성. 원본 클래스들을 하위 클래스로 만들자
- 필드 상향, 메서드 상향, 생성자 내용 상향 적용
- 컴파일, 테스트

---
## 인터페이스 추출 Extract Interface
- 클래스 인터페이스의 같은 부분을 여러 클라이언트가 사용하거나, 
두 클래스에 인터페이스의 일부분이 공통으로 들어 있을 땐 공통 부분을 인터페이스로 빼내자

### 동기
- 상위클래스 추출과 인터페이스 추출은 비슷함
  - 인터페이스 추출은 공통된 코드를 빼내는 것이 아니라 공통된 인터페이스만 빼내는 기법
  - 공통 기능이 많을 땐 상위클래스 추출이 더 간단하지만 상위클래스가 하나로 제한됨

### 방법
- 빈 인터페이스 작성
- 공통 기능을 인터페이스 안에 선언
- 그 인터페이스를 상속구현하는 관련 클래스를 선언
- 그 인터페이스를 사용하게 클라이언트의 타입 선언 코드를 수정  

---
## 계층 병합 Collapse Hierarchy
- 상위클래스와 하위클래스가 거의 다르지 않을 땐 둘을 합치자

### 방법
- 상위클래스와 하위클래스 중 무엇을 삭제할지 선택
- 필드 상향, 메서드 상향(or 하향)을 적용
- 컴파일, 테스트
- 참조하는 부분 수정
- 빈 클래스 삭제
- 컴파일, 테스트 

---
## 템플릿 메서드 형성 Form Template Method
- 하위클래스 안의 두 메서드가 거의 비슷한 단계들을 같은 순서로 수행할 땐
그 단계들을 시그니처가 같은 두 개의 메서드로 만들어서 두 원본 메서드를 같게 만든 후,
두 메서드를 상위클래스로 옮기자.

### 동기
- 상속은 중복된 기능을 없애는 강력한 수단
  - 하위 클래스에 들어있는 두 메서드가 비슷하다면 중복된 부분은 가능한 없애고 필수 부분만 그대로 두기
- 두 메서드가 똑같지는 않지만 거의 비슷한 단계를 같은 순서로 수행하는 경우
  - 순서를 상위클래스로 옮기고 재정의를 통해 각 단계가 고유의 작업을 다른 방식으로 수행하게 한다.
  - [템플릿 메서드](https://gmlwjd9405.github.io/2018/07/13/template-method-pattern.html)

### 방법
- 추출된 메서드 전부를 똑같거나 전혀 다르게 분해
- 메서드 상향
- 서로 다른 메서드를 대상으로 메서드명 변경을 실시해서 시그니처를 같게 만들자
- 시그니처를 수정할 때마다 컴파일, 테스트
- 원본 메서드 중 하나에 메서드 상향을 실시
- 다른 메서드의 시그니처를 상위클래스에 abstract 타입의 메서드로 정의
- 컴파일, 테스트

---
## 상속을 위임으로 전환 Replace Inheritance with Delegation
- 하위클래스가 상위클래스 인터페이스의 일부만 사용할 때나 데이터를 상속받지 않게 해야 할 땐 상위클래스에 필드를 작성하고,
모든 메서드가 그 상위클래스에 위임하게 수정한 후 하위클래스를 없애자.

### 동기
- 상속이 적합하지 않은 경우 
  - 클래스의 기능이 인터페이스에 제대로 반영되지 않았거나
  - 하위클래스로 적절하지 않은 많은 데이터를 상속하게 작성했거나
  - 상위클래스의 protected 메서드가 하위클래스에 시용되지 않는 경우
- 상속 대신 위임을 이용하면 위임받은 클래스의 일부만 사용하려는 의도가 더욱 확실해진다.
  - 인터페이스의 어느 부분을 사용하고 어느 부분을 무시할지 개발자가 제어할 수 있다.
  - 단지 위임하는 메서드를 추가로 작성하면 된다.

### 방법
- 하위클래스 안에 상위클래스의 인스턴스를 참조하는 필드를 작성하자. 그 필드를 this로 초기화하자.
- 하위클래스 안의 각 메서드를 수정해서 대리 필드를 사용하게 하자. 각 메서드를 수정할 때마다 컴파일, 테스트
- 하위클래스 선언을 삭제하고 대리 객체 대입 부분을 새 객체 대입으로 바꾸자.
- 클라이언트가 사용하는 상위클래스 메서드마다 간단한 위임 메서드를 추가
- 컴파일, 테스트

---




























