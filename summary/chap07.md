# Chapter 07 객체 간의 기능 이동
- 메서드 이동 Move Method
- 필드 이동 Move Field
- 클래스 추출 Extract Class
- 클래스 내용 직접 삽입 Inline Class
- 대리 객체 은폐 Hide Delegate
- 과잉 중개 메서드 제거 Remove Middle Man
- 외래 클래스에 메서드 추가 Introduce Foreign Method
- 국소적 상속확장 클래스 사용 

---
### 메서드 이동 Move Method
- 메서드가 자신이 속한 클래스보다 다른 클래스의 기능을 더 많이 이용할 땐 그 메서드가 제일 많이 이용하는 클래스 안에서 비슷한 내용의 새 메서드르 작성하자. 기존 메서드는 간단한 대리 메서드로 전환하든지 아예 삭제하자.

**동기**
- 클래스에 기능이 너무 많거나 다른 클래스와 과하게 연동되어 의존성이 지나칠 때

**방법**
- 원본 클래스에 정의되어 있는 원본 메서드에 사용된 기능을 모두 검사 
  - 옮길 메서드에만 사용되는 기능도 함께 옮겨야 한다. 
- 원본 클래스의 하위, 상위 클래스에서 그 메서드에 대한 다른 선언이 있는지 검사  
  - 다른 선언이 있다면 대상 클래스에도 재정의를 넣을 수 있을때만 옮길 수 있을지도 모른다.
- 그 메서드를 대상 클래스 안에 선언  
  - 대상 클래스에 더 어울리는 이름으로 정의해도 된다.
- 코드를 복사한 후, 대상 클래스 안에서 잘 돌아가게 수정  
  - 대상 메서드가 원본 메서드를 사용한다면 대상 메서드 안에서 원본 객체를 참조할 방법을 정해야 한다.  대상 클래스에 원본 객체를 참조하는 기능이 없다면 원본 객체 참조를 대상 메서드에 매개 변수로 전달하자.  
  - 대상 메서드에 **예외처리 코드**가 들어있다면 예외를 어느 클래스가 처리할지 정하자.
- 대상 클래스를 컴파일  
- 원본 객체에서 대상 객체를 참조할 방법을 정하자 
  - 대상 클래스를 참조하는 속성이나 메서드가 없다면 원본 클래스 안에 대상 클래스를 저장할 수 있는 새 속성을 선언해야 한다.  
- 원본 메서드를 위임 메서드로 전환하자.??
- 컴파일, 테스트
- 원본 메서드를 삭제하든지, 아니면 위임 메서드로 사용하게 두기
  - 참조가 많을 때는 원본 메서드를 위임 메서드로 내버려두는 방법이 더 편하다.
- 원본 메서드를 삭제할 때는 기존의 참조를 전부 대상 메서드 참조로 수정하자.
- 컴파일, 테스트  

---
### 필드 이동 Move Field  
- 어떤 필드가 자신이 속한 클래스보다 다른 클래스에서 더 많이 사용될 때는 대상 클래스 안에 새 필드를 선언하고 그 필드 참조 부분을 전부 새 필드 참조로 수정하자.

**동기**
- 인터페이스에 따라 메서드를 옮기는 방법을 사용할 수도 있지만 메서드 위치가 적절하면 필드를 옮긴다.
- 클래스 추출을 실시하는 중에도 해당 기법이 수반된다. 이럴 땐 필드가 우선이고 메서드는 다음이다.  

**방법**
- 필드가 public이면 필드 캡슐화 기법을 실시하자
  - 필드에 자주 접근하는 메서드를 옮기게 될 가능성이 높거나 그 필드에 많은 메서드가 접근할 때는 필드 자체 캡슐화를 실시하자  
- 컴파일, 테스트  
- 대상 클랫 안에 읽기/쓰기 메서드와 함께 필드를 작성  
- 대상 클래스 컴파일 
- 원본 객체에서 대상 객체 참조할 방법을 정하자  
  - 기존 필드나 메서드에 대상 클래스를 참조하는 기능이 있을수도 있다. 
- 원본 클래스에서 필드를 삭제하자
- 원본 필드를 참조하는 모든 부분을 대상 클래스에 있는 적절한 메서드를 참조하게 수정하자  
  - 변수 접근 참조 부분은 대상 객체의 읽기 메서드 호출로 수정하고, 대입 참조 부분은 쓰기 메서드 호출로 수정  
  - 필드가 private이 아니면 원본 클래스의 모든 하위 클래스를 뒤져서 필드 참조 부분을 찾아내자
- 컴파일, 테스트
- 
---
### 클래스 추출 Extract Class
- 두 클래스가 처리해야할 기능이 하나의 클래스에 들어 있을 땐 새 클래스를 만들고 기존 클래스의 관련 필드와 메서드를 새 클래스로 옮기자  

**동기**
- 데이터의 일부분과 메서드의 일부분이 한 덩어리이거나, 주로 함께 변화하거나 서로 유난히 의존적인 데이터의 일부분도 클래스로 떼어내기 좋다. 이것을 판단하는 좋은 방법은 데이터나 메서드를 하나 제거하면 어떻게 될지, 다른 필드와 메서드를 추가하는 건 합리적이지 않은지 자문해보는 것  
- 개발 후반부에 들어서면 대체로 클래스 타입을 상속받는 방식을 알 수 있다. 타입 상속은 몇몇 기능에만 영향을 미칠 수도 있고, 기능에 띠라 다른 방식의 타입 상속을 해야할 수도 있다??  

**방법**
- 클래스의 기능 분리 방법을 정하자  
- 분리한 기능을 넣을 새 클래스를 작성하자  
  - 원본 클래스의 기능이 이름과 어울리지 않으면 수정  
- 원본 클래스에서 새 클래스로의 링크를 만들자  
  - 양방향 링크가 필요할 수도 있는데 필요할 때까진 역방향 링크를 만들지 말자  
- 옮긴 필드마다 필드 이동을 적용, 컴파일, 테스트  
- 메서드 이동을 실시해서 원본 클래스의 메서드를 새 클래스로 옮기자. 하급 메서드(피호출 메서드)부터 시작해서 상급 메서드(호출 메서드)에 적용하자??  
- 메서드 이동 실시할 때마다 테스트
- 각 클래스를 다시 검사해서 인터페이스를 줄이자  
  - 양방향 링크가 있다면 단방향으로 바꾸기  
- 여러 곳에서 클래스에 접근할 수 있게 할지 결정
  - 여러 곳에서 접근할 수 있게 할 경우, 새 클래스를 참조 객체나 변경불가 값 객체로서 공개할지 여부  

---
### 클래스 내용 직접 삽입 Inline Class
- 클래스에 기능이 너무 적을 땐 그 클래스의 모든 기능을 다른 클래스로 합쳐 넣고 원래의 클래스는 삭제하자  

**동기**
- 클래스 추출과 반대  
- 주로 클래스의 기능 대부분을 다른 곳으로 옮기는 리팩토링을 실시해서 남은 기능이 거의 없을 때  

**방법**
- 원본 클래스의 public 프로토콜 메서드를 합칠 클래스에 선언하고 이 메서드르 전부 원본 클래스에 위임하자
  - 원본 클래스의 메서드 대신 별도의 인터페이스가 알맞다고 판단되면 클래스 내용 직접 삽입을 실시하기 전에 인터페이스 추출 기법을 실시하자  
- 원본 클래스의 모든 참조를 합칠 클래스 참조로 수정하자  
  - 원본 클래스를 private으로 선언하고 패키지 밖의 참조를 삭제하자. 
- 컴파일, 테스트  
- 메서드 이동과 필드 이동을 실시해서 원본 클래스의 모든 기능을 합칠 클래스로 옮기자  
- 원본 클래스 삭제  

---
### 대리 객체 은폐 Hide Delegate
- 클라이언트가 객체의 대리 클래스를 호출할 땐 대리 클래스를 감추는 메서드를 서버에 작성하자 

**동기**
- 객체에서 핵심 개념 중 하나가 바로 캡슐화  
  - 캡슐화란 객체가 시스템의 다른 부분에 대한 정보의 일부만 알 수 있게 은폐하는 것을 뜻한다.
  - 객체를 캡슐화하면 무언가를 변경할 때 그 변화를 전달해야 할 객체가 줄어들므로 변경 용이
- 클라이언트가 서버 객체의 필드 중 하나에 정의된 메서드를 호출할 때 그 클라이언트는 이 대리 객체에 관해 알아야 한다.
  - 대리 객체가 변경될 때 클라이언트도 변경해야 할 가능성이 있기 때문
  - 이러한 의존성을 없애려면 대리 객체를 감추는 위임 메서드를 서버에 두면 된다.

**방법**
- 대리 객체에 들어 있는 각 메서드를 대상으로 서버에 간단한 위임 메서드를 작성하자 
- 클라이언트를 수정해서 서버를 호출하게 만들자
  - 클라이언트 클래스가 서버 클래스와 같은 패키지에 들어 있지 않다면 대리 메서드의 접근을 같은 패키지에 든 클래스만 접근할 수 있게 수정하는 것을 고려하자  
- 각 메서드를 수정할 때마다 컴파일, 테스트 
- 대리 객체를 읽고 써야 할 클라이언트가 하나도 남지 않게 되면, 서버에서 대리 객체가 사용하는 읽기/쓰기 메서드를 삭제하자  
- 컴파일, 테스트  

---
### 과잉 중개 메서드 제거 Remove Middle Man
- 클래스에 자잘한 위임이 너무 많을 땐 대리 객체를 클라이언트가 직접 호출하게 하자

**동기**
- 대리 객체 은폐 기법에서 객체 사용을 캡슐화하면 얻는 장점에 대해 설명했다. 하지만 장점을 얻는 대신 단점도 생긴다.  
  - 클라이언트가 대리 객체의 새 기능을 사용해야 할 때마다 서버에 위임 메서드를 추가해야 한다는 점이다.
- 은폐의 적절한 정도를 알기란 어렵다. 다행히 대리 객체 은폐와 과잉 중개 메서드 제거를 실시할 때는 은폐의 정도를 잘 몰라도 된다.  
  - 시스템이 변경되면 은폐 정도의 기준도 변하기 때문에 시간을 두고 필요해질 때마다 보수하면 된다.

**방법**
- 대리 객체에 대한 접근 메서드를 작성하자
- 대리 메서드를 클라이언트가 사용할 때마다 서버에서 메서드를 제거하고 클라이언트에서의 호출을 대리 객체에서의 메서드 호출로 교체  
- 메서드를 수정할 때마다 테스트 

---
### 외래 클래스에 메서드 추가 Introduce Foreign Method
- 사용중인 서버 클래스에 메서드를 추가해야 하는데 그 클래스를 수정할 수 없을 땐 클라이언트 클래스 안에 서버 클래스의 인스턴스를 첫번째 인자로 받는 메서드를 작성하자 

**[BEFORE]**
```java
Date newStart = new Date (previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + 1);
```

**[AFTER]**
```java
Date newStart = nextDay(previousEnd);
private static Date nextDay(Date arg) {
    return new Date (arg.getYear(), arg.getMonth(), arg.getDate() + 1);
}
```

**동기**
- 필요한 메서드를 클라이언트 클래스 안에서 한 번만 사용한다면 괜찮다.
  - 여러 클래스에서 필요한 경우에는 중복을 막기 위해 하나의 메서드로 만들어야 한다.
    - 새로 만들 메서드를 외래 메서드??로 만들면 그 메서드가 원래는 원본 메서드인 서버 메서드??에 있어야 할 메서드임을 분명이 나타낼 수 있다.  
- 서버 클래스에 수많은 외래 메서드를 작성해야 하거나 하나의 외래 메서드를 여러 클래스가 사용해야 할 때는 이 기법 대신 국소적 상속확장 클래스 사용 기법을 실시  
- 외래 메서드는 임시 방편에 불과하다. 가능하면 원래 있어야 할 위치로 옮기자  

**방법**
- 필요한 기능의 메서드를 클라이언트 클래스 안에 작성  
  - 그 메서드는 클라이언트 클래스의 어느 기능에도 접근해선 안된다. 그 메서드에 값이 필요할 땐 매개변수로 전달해야 한다.  
- 서버 클래스의 인스턴스를 첫 번째 매개변수로 만들자
- 그 메서드에 '서버 클래스에 있을 외래 메서드' 같은 주석 추가

---
### 국소적 상속확장 클래스 사용 Introduce Local Extension
- 사용 중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐 새 클래스를 작성하고 그 안에 필요한 여려 개의 메서드를 작성하자.이 상속확장 클래스를 원본 클래스의 하위 클래스나 래퍼 클래스로 만들자.

**동기**
- 원본 클래스를 수정 할 수 없을 때 
  - 필요한 메서드가 한두개 : 외래 클래스에 메서드 추가 기법 
  - 필요한 메서드가 세 개 이상 : 국소적 상속확장 클래스 사용 
- 국소적 상속확장 클래스는 별도의 클래스지만 상속확장하는 클래스의 하위 타입이다.
  - 따라서 원본 클래스의 모든 기능도 사용 가능하면서 추가 기능도 들어 있다. 
  - 원본 클래스를 사용할 것이 아니라 국소적 상속확장 클래스를 인스턴스화해서 사용하자.  
- 국소적 상속확장 클래스를 사용하면 메서드와 데이터가 체계적인 단위로 묶여야 한다는 원칙이 저절로 지켜진다. 

**방법**
- 상속확장 클래스를 작성한 후 원본 클래스의 하위클래스나 래퍼 클래스로 만들자 
- 상속확장 클래스에 변환 생성자 메서드를 작성하자  
  - 생성자는 원본 클래스를 인자로 받는다. 하위 클래스의 경우 적절한 상위 클래스 생성자를 호출하며, 래퍼 클래스의 경우 대리 필드에 그 인자를 할당한다  
- 상속확장 클래스에 새 기능을 추가하자  
- 필요한 위치마다 원본 클래스를 상속확장 클래스로 수정하자  
- 이 클래스용으로 정의된 외래 메서드를 전부 상속확장 클래스로 옮기자  
- 











